# 概述


## IO 多路复用
select、poll 以及 epoll 是 Linux 系统的三个系统调用，也是 IO 多路复用模型的具体实现

由前文 五种常见IO模型我们可以知道，IO 多路复用就是通过一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作的一种机制

### 1. select==>时间复杂度O(n)
调用过程
1. 用户进程需要监控某些资源 fds，在调用 select 函数后会阻塞，操作系统会将用户线程加入这些资源的等待队列中
2. 直到有描述副就绪（有数据可读、可写或有 except）或超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回
3. select 函数返回后，中断程序唤起用户线程。用户可以遍历 fds，通过 FD_ISSET 判断具体哪个 fd 收到数据，并做出相应处理

它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。
1. 每次调用 select 都需要将进程加入到所有监视 fd 的等待队列，每次唤醒都需要从每个队列中移除。 这里涉及了两次遍历，而且每次都要将整个 fd_set 列表传递给内核，有一定的开销。
2. 当函数返回时，系统会将就绪描述符写入 fd_set 中，并将其拷贝到用户空间。进程被唤醒后，用户线程并不知道哪些 fd 收到数据，还需要遍历一次

所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长

单个进程可监视的fd数量被限制，即能监听端口的大小有限，32位机默认是1024个。64位机默认是2048

(2)poll==>时间复杂度O(n)
poll本质上和select没有区别，唯一的区别是数据结构
poll 是链表方式替代 select 中的 fd_set 结构，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，
因为它是基于链表来存储的，所以它没有最大连接数的限制

(3)epoll==>时间复杂度O(1)
epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。采用回调方式检测就绪时间，复杂度降低到了O(1)
epoll 使用一个文件描述符管理多个描述符，将用户进程监控的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间只需拷贝一次