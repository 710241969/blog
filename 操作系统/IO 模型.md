___
# BIO，同步阻塞
Blocking IO，阻塞 IO

**术语描述**：在应用调用recvfrom读取数据时，其系统调用直到数据包到达且被复制到应用缓冲区中或者发送错误时才返回，在此期间一直会等待，进程从调用到返回这段时间内都是被阻塞的称为阻塞IO；

**流程：**
1、应用进程向内核发起recfrom读取数据。
2、准备数据报（应用进程阻塞）。
3、将数据从内核负责到应用空间。
4、复制完成后，返回成功提示。

监听请求、IO流都是阻塞的

由于用户进程（线程）每一次`recvfrom`系统调用都是阻塞且只对应一个文件描述符，此时如果服务端线程阻塞于客户端A的读操作时，如果有另外的客户端B需要接入服务端，此时服务端线程由于阻塞于客户端A的读操作，因此无法处理客户端B的连接操作。

___
# 非阻塞IO，同步非阻塞

按照上面的思路，所谓非阻塞IO就是当应用B发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用B，不会让B在这里等待。

**术语**：非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要不断的调用recvfrom请求，直到读取到它数据要的数据为止。
就是用 for 循环一直调用

**流程：
![[Pasted image 20230523160317.png]]**
1、应用进程向内核发起recvfrom读取数据。
2、没有数据报准备好，即刻返回EWOULDBLOCK错误码。
3、应用进程向内核发起recvfrom读取数据。
4、已有数据包准备好就进行一下 步骤，否则还是返回错误码。
5、将数据从内核拷贝到用户空间。
6、完成后，返回成功提示。

___
# NIO，同步非阻塞
New IO，IO 复用模型

由一个线程监控多个网络请求（我们后面将称为fd文件描述符，linux系统把所有网络请求以一个fd来标识），这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。

客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。

参考 [[IO 多路复用]]

流程
![[Pasted image 20230523160428.png]]

正是基于一次recvfrom系统调用中一个线程的select操作可以选择多个文件描述符这个功能，我们现在用一个用户线程就能监听不同`channel`的`OP_CONNECT`,`OP_ACCEPT`,`OP_READ`和`OP_WRITE`这些就绪事件，然后根据某个就绪事件拿到相应的`channel`来做对应的操作。而不用像阻塞IO模型或非阻塞IO模型那样，一次recvfrom系统调用中一个线程就只能选择一个文件描述符，这样就严重限制了伸缩性。

## java
jdk1.4 开始支持

单独的线程来监视多个输入通道，可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入或选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道

其实IO复用模型真正占优势的地方在于`select`操作，这个`select`操作可以选择多个文件描述符，分别对应Java NIO中的`OP_CONNECT`,`OP_ACCEPT`,`OP_READ`和`OP_WRITE`就绪事件。

Channel ServerSocketChannel ScoketChannel DatagramChannel FileChannel FileChannel比较特殊，它可以与通道进行数据交互， 不能切换到非阻塞模式，套接字通道可以切换到非阻塞模式

Selector 多路复用器

Buffer position limit capacity 一个数组

___
# 信号驱动 IO，同步非阻塞
术语描述：首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知应用线程调用recvfrom来读取数据。

流程
![[Pasted image 20230523162728.png]]




___
# AIO，异步非阻塞
Asynchronous Input and Output，异步非阻塞I/O，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由操作系统先完成了再通知服务器用其启动线程进行处理

流程
![[Pasted image 20230523162054.png]]

JAVA 1.7版本中加入的NIO2.0（AIO）对异步IO的实现


___
# 信号驱动 IO 和 AIO 比较
**扩展：** 异步IO模型跟信号驱动IO模型的区别在于当内核准备好数据报后，对于信号驱动IO模型，此时内核会通知用户进程说数据报准备好啦，你需要发起系统调用来将数据报从内核拷贝到用户空间，此过程是同步阻塞的；而对于异步IO模型，当数据报准备好时，内核不会再通知用户进程，而是自己默默将数据报从内核拷贝到用户空间后然后再通知用户进程说，数据已经拷贝到用户空间啦，你直接进行业务逻辑处理就行。

___
# 阻塞和非阻塞比较
阻塞就是发起读取数据请求的时，当数据还没准备就绪的时候，这时请求是即刻返回，还是在这里等待数据的就绪，如果需要等待的话就是阻塞，反之如果即刻返回就是非阻塞

___
# 同步和异步比较
在IO模型里面如果请求方从发起请求到数据最后完成的这一段过程中都需要自己参与，那么这种我们就称为同步请求；反之，如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于异步。

数据报从内核复制到用户空间，这一过程是阻塞的
数据准备好之后，要自己去从内核取数据的，就是同步。
数据准备好之后，内核把数据拷贝到用户空间的操作也完成了，我们能够直接用，叫异步。

___
# 同步阻塞，同步非阻塞，异步非阻塞比较
同步阻塞、同步非阻塞，他们不同的只是发起读取请求的时候一个请求阻塞，一个请求不阻塞，但是相同的是，他们都需要应用自己监控整个数据完成的过程。

只有异步非阻塞，而**没有异步阻塞**，因为异步模型下请求指定发送完后就即刻返回了，没有任何后续流程了，所以它注定不会阻塞，所以也就只会有异步非阻塞模型了。
