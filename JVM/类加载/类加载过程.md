# 加载过程
JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次
java 文件编译后， JVM 类加载机制分为五个部分：加载，连接（包括：验证，准备，解析），初始化，使用，卸载

## 1. 编译
即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件
类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程

## 2.加载过程
![[Pasted image 20230509154820.png]]

### 加载
**加载**是**类加载**过程中的一个阶段

将 class 文件字节码内容，生成类的元数据放入**方法区**中，里面放置了类的基本信息，包括类的版本、字段、方法、接口以及常量池表（Constant Pool Table）等**运行时数据结构**。**Java的对象（包括class对象）中保存着指向相应类的元数据的引用**。


这个阶段会还在**堆**中生成一个代表这个类的`java.lang.Class`对象，作为这个类在方法区的元数据的访问入口，也就是说**Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口**

这个过程需要[[[类加载器]]]参与

1. 通过一个类的全限定名获取类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

4. ZIP包读取，如jar包，war包
5. 从网络读取
6. 运行时生成，动态代理
7. 其他文件生成，如jsp文件生成对应的class类

### 验证
确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

### 准备
正式为**类变量**分配内存并设置类变量的初始值阶段，在方法区中分配这些变量所使用的内存空间
如
```java
public static int v = 123;
```
在准备阶段过后的初始值为 0，在初始化阶段才会赋值
但如果是**类常量**
```java
public static final int v = 123;
```
则在准备阶段就会赋值为123

### 解析
将符号引用替换为直接引用过程，这一步可以发生在运行时

### 符号引用
即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息

### 直接引用
可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量

由于在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，所以如果你在一个类中引用了另一个类，那么你完全无法知道他的内存地址，那怎么办，我们只能用他的类名作为符号引用，在类加载完后用这个符号引用去获取他的内存地址

比如说多态中的动态绑定，要到运行时再去替换符号引用，因为在类加载时还没有明确的类型

### 初始化


