___
# 概述
当主从服务器刚建立连接的时候，进行全量同步；全量复制结束后，进行增量复制。当然，如果有需要，slave 在任何时候都可以发起全量同步。

___
# 过程
在 Redis的主从复制实现中，包含两个类似阶段：全量数据同步和命令传播。

## 全量数据同步
主节点产生一份全量数据的快照，即RDB文件，并将此快照发送给从节点。同时**主库**为每一个 slave 开辟一块 replication buffer 缓冲区记录从生成 RDB 文件开始收到的所有写命令。当快照发送完成后，将累积的写命令发送绐从节点，从节点执行这些写命令。此时基准已经建立完成。

从库收到 RDB 文件后保存到磁盘，并清空当前数据库的数据，再加载 RDB 文件数据到内存中。（先存磁盘，在清除内存数据，最后加载rdb进入内存）

### replication buffer解释？
一个在 master 端上创建的缓冲区，存放的数据是下面三个时间内所有的 master 数据写操作。
1）master 执行 bgsave 产生 RDB 的期间的写操作；
2）master 发送 rdb 到 slave 网络传输期间的写操作；
3）slave load rdb 文件把数据恢复到内存的期间的写操作。

**每个** client （客户端通信，从库通信）连上 Redis 后，Redis 都会分配一个专有 client buffer，所有数据交互都是通过这个 buffer 进行的。（Master 先把数据写到这个 buffer 中，然后再通过网络发送出去，这样就完成了数据交互）。buffer 专门用来传播写命令到从库，保证主从数据一致，我们通常把它叫做 replication buffer。

## 增量数据同步
全量数据同步完成后，主节点将执行过的写命令源源不断地发送给从节点，从节点执行这些命令，保证主从节点中数据有相同的变更，如此保证主从节点数据的一致。

##  部分同步
![[Pasted image 20230526011623.png]]
Redis 2.8 版本后，引入了部分同步。它在主节点中维护了一个复制积压缓冲区，命令一方面会传播到从节点，另外还会记录在这个缓冲区中。保持所有的命令是不必要的，Redis 中使用了一个环形的缓冲区，这样就可以只保留最近的一些命令了。

命令已经保存下来了，但从节点重新连接后，主节点该从什么地方开始给从节点发送命令呢？如果能给所有命令编一个号，则从节点只需要告诉主节点自己最后收到的命令的编号，主节点就知道该从什么位置发送命令了。Redis 的实现中是对字节进行编号，这个编号在 Redis 的语境中叫做复制偏移量。

主从复制的时候不再使用 SYNC 命令，而是使用 PSYNC，意思的 Partial SYNC。PSYNC 的语法如下：
```
PSYNC   <master   id>   <replication    offset>
```

命令中的两个参数，一个是主节点的编号，一个是复制偏移量。每个Redis节点都有一个 40 字节的编号，PSYNC 命令中携带的编号是期望进行同步的主节点的编号。复制偏移量则表示当前从节点想要从什么地方开始部分同步。

从节点根据当前状态，发送 psync命令给 master：
如果从节点从未执行过 replicaof ，则从节点发送 psync ? -1，向主节点发送全量复制请求；
如果从节点之前执行过 replicaof 则发送 psync <runID> <offset>, runID 是上次复制保存的主节点 runID，offset 是上次复制截至时从节点保存的复制偏移量。
主节点根据接受到的psync命令和当前服务器状态，决定执行全量复制还是部分复制：
runID 与从节点发送的 runID 相同，且从节点发送的 slave_repl_offset之后的数据在 repl_backlog_buffer缓冲区中都存在，则回复 CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；
runID 与从节点发送的 runID 不同，或者从节点发送的 slave_repl_offset 之后的数据已不在主节点的 repl_backlog_buffer缓冲区中 (在队列中被挤出了)，则回复从节点 FULLRESYNC <runid> <offset>，表示要进行全量复制，其中 runID 表示主节点当前的 runID，offset 表示主节点当前的 offset，从节点保存这两个值，以备使用。




## 主从同步配置
min-slaves-to-write 1  
min-slaves-max-lag 10

要求至少有1个slave，数据复制和同步的延迟不能超过10秒
如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了

## 为什么使用RDB不使用AOF文件？
AOP文件比RDB文件大，网络传输比较耗时。
RDB 文件是二进制文件，网络传输 RDB 和写入磁盘的 IO 效率都要比 AOF 高。
在从库初始化数据时，RDB比AOF文件执行的更快