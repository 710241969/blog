___
# redis 过期策略
我们set key的时候，都可以给一个expire time，就是过期时间，指定这个key比如说只能存活1个小时，我们自己可以指定缓存到期就失效。

如果一个键过期了，那么它什么时候会被删除呢?
1. 定时删除，设置一个定时器和回调函数，时间一到就调用回调函数删除键值对。优点是及时删除，缺点是需要为每个键值对都设置定时器，比较麻烦(其实可以用timer_fd的，参考muduo定时任务的实现)
2. 惰性删除，只有当再次访问该键时才判断是否过期，如果过期将其删除。优点是不需要为每个键值对进行时间监听，缺点是如果这个键值对一直不被访问，那么即使过期也会一直残留在数据库中，占用不必要的内存
3. 周期删除，每隔一段时间执行一次删除过期键值对的操作。优点是既不需要监听每个键值对导致占用CPU，也不会一直不删除导致占用内存，缺点是不容易确定删除操作的执行时长和频率

## 定时删除
定时删除策略的做法是，在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。

### 优点：
可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。

### 缺点：
在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。


## 惰性删除(被动删除)
惰性删除策略的做法是，不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。

### 优点：
因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。

### 缺点：
如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。

## 定期删除
从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷:
	定时删除占用太多CPU 时间，影响服务器的响应时间和吞吐量。
	惰性删除浪费太多内存，有内存泄漏的危险。

定期删除策略的做法是，每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。

定期删除策略的优点：

通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。
定期删除策略的缺点：

内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。
难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。

## 其他模块对过期键的处理

## 生成RDB文件时
执行 SAVE 或 BGSAVE 时 ，数据库键空间中的过期键不会被保存在RDB文件中

## 载入RDB文件时
Master 载入RDB时，文件中的未过期的键会被正常载入，过期键则会被忽略。
Slave 载入 RDB 时，文件中的所有键都会被载入，当同步进行时，会和Master 保持一致。

## AOF 文件写入时
数据库键空间的过期键的过期但并未被删除释放的状态会被正常记录到 AOF 文件中，当过期键发生释放删除时，DEL 也会被同步到 AOF 文件中去。

## 重新生成 AOF文件时
执行 BGREWRITEAOF 时 ，数据库键中过期的键不会被记录到 AOF 文件中

## 主从复制
Master 删除过期 Key 之后，会向所有 Slave 服务器发送一个 DEL命令，从服务器收到之后，会删除这些 Key。
Slave 在被动的读取过期键时，不会做出操作，而是继续返回该键，只有当Master 发送 DEL 通知来，才会删除过期键，这是统一、中心化的键删除策略，保证主从服务器的数据一致性。

___
# 内存淘汰机制
前面说的过期删除策略，是删除已过期的 key，而当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。

所以下面的淘汰策略，全部都有一个前提，就是**内存不足以容纳新写入数据**

## 不淘汰
### noeviction
（Redis3.0之后，默认的内存淘汰策略）：新写入操作会报错

## 在所有数据范围内进行淘汰
## allkeys-lru
在全部键空间中，移除**最近最少**使用的key（这个是最常用的）

## allkeys-random
在全部键空间中，随机淘汰任意键值

## allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）
在全部键空间中，淘汰整个键值中**最少**使用的键值

## 在设置了过期时间的数据中进行淘汰

### volatile-random
在设置了过期时间的键空间中，随机移除某个key

### volatile-lru
在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）

### volatile-ttl
在设置了过期时间的键空间中，有更早过期时间的key优先移除

## volatile-lfu（Redis 4.0 后新增的内存淘汰策略）
在设置了过期时间的键空间中，淘汰最少使用的键值；
