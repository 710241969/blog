# 概述
Kafka是一个分布式流处理系统，流处理系统使它可以像消息队列一样publish或者subscribe消息，分布式提供了容错性，并发处理消息的机制。

## 消息队列
消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。

消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在

## 应用场景
* 应用解耦：一个服务产生的数据有多个其他服务需要用到，通过消息队列进行解耦
* 应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败
* 异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间
* 限流削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况
* 消息驱动的系统：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理

# 基本概念
kafka运行在集群上，集群包含一个或多个服务器。kafka把消息存在topic中，每一条消息包含键值（key），值（value）和时间戳（timestamp）。

kafka有以下一些基本概念：
## Producer
消息生产者，就是向kafka broker发消息的客户端。

## Consumer
消息消费者，是消息的使用方，负责消费Kafka服务器上的消息。

## Topic
主题，由用户定义并配置在Kafka服务器，用于建立Producer和Consumer之间的订阅关系。生产者发送消息到指定的Topic下，消息者从这个Topic下消费消息。

## Partition
消息分区，一个topic可以分为多个 partition，每个 partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。

Kafka 可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，只要分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡和水平扩展。另外，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力。在默认情况下消息分发是轮询均匀分配到 partition 的。

producer 只需要关心消息发往哪个 topic，而 consumer 只关心自己订阅哪个 topic，并不关心每条消息存于整个集群的哪个 broker。 为了性能考虑，如果 topic 内的消息只存于一个 broker，那这个 broker 会成为瓶颈，无法做到水平扩展。所以把 topic 内的数据分布到整个集群就是一个自然而然的设计方式。

> Partition 的引入就是解决水平扩展问题的一个方案。

## Broker
一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。

## Consumer Group
消费者分组，用于归组同类消费者。每个consumer属于一个特定的consumer group，多个消费者可以共同消息一个Topic下的消息，每个消费者消费其中的部分消息，这些消费者就组成了一个分组，拥有同一个分组名称，通常也被称为消费者集群。

## Offset
消息在partition中的偏移量。每一条消息在partition都有唯一的偏移量，消息者可以指定偏移量来指定要消费的消息。

## Leader 和 Follower
一个分区会有多个副本，副本之间是一主(Leader)多从(Follower)的关系，Leader 对外提供服务，这里的对外指的是与客户端程序进行交互，而 Follower 只是被动地同步 Leader 而已，不能与外界进行交互。

当然了，你可能知道在很多其他系统中 Follower 是可以对外提供服务的，比如 MySQL 的从库是可以处理读操作的，但是在 Kafka 中 Follower 只负责消息同步，不会对外提供服务

# 同一个消息重复消费
同一个消息重复消费，根据经验是必然会发生的事情，无论怎么记录消费情况，都有消费完未记录的可能性发生
应当从消费者出发，做好幂等设计，在重复消费相同数据的时候能得到一样的结果







