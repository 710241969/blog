___
# 概述
Java为了屏蔽硬件和操作系统访问内存的各种差异，提出了「Java内存模型」的规范，保证了Java程序在各种平台下对内存的访问都能得到一致效果

Java内存模型它是一种「规范」，是定义了一种多线程访问Java内存的规范，Java虚拟机会实现这个规范。

并发问题产生的三大根源是，**可见性、原子性、有序性**问题

Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：
1. Java内存模型的抽象结构
（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去

也就是Java内存模型定义了8种操作来完成「变量如何从主内存到本地内存，以及变量如何从本地内存到主内存」

（2）定义了几个原子操作，用于操作主内存和工作内存中的变量

（3）定义了volatile变量的使用规则
Java内存模型为了实现volatile有序性和可见性，定义了4种内存屏障的「规范」，分别是LoadLoad/LoadStore/StoreLoad/StoreStore
volatile「前后」加上「内存屏障」，使得编译器和CPU无法进行重排序，致使有序，并且写volatile变量对其他线程可见

（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的

可见性
volatile
synchronized 利用synchronized关键字。syn块内部读写变量，隐式调用内存lock、unlock指主动读写丰存

___
# Happens-Before
字面翻译过来就是先行发生， A happens-before B 就是A先行发生于B ？
这是不准确的

**前面一个操作的结果对后续操作是可见的，即前一个操作的结果可以被后续的操作获取**

程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！

管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）

volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。

线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。

线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。

线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。

传递规则：这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。

对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法




构造函数中 this 引用逸出的问题
this引用逃逸（"this"escape）是指对象还没有构造完成，它的this引用就被发布出去了
final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化
Java 编译器在 1.5 以前的版本的确优化得很努力，以至于都优化错了
构造函数的错误重排导致线程可能看到 final 变量的值会变化
在下面例子中，在构造函数里面将 this 赋值给了全局变量 global.obj，这就是“逸出”
线程通过 global.obj 读取 x 是有可能读到 0 的
```Java
public class FinalReferenceEscapeExample {
    final int i;
    static FinalReferenceEscapeExample OBJ;
 
    // 错误的构造函数
    public FinalReferenceEscapeExample () {
        i = 1;
        // 此处就是将 this 逸出，
        OBJ = this;
    }
}
```
回忆一下类的初始化过程。这里可能由于重排序， this 还没有初始化完就先赋值到了 OBJ 中


1. 在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序
2. 初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能