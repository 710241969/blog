# 加载过程
JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次
java 文件编译后， JVM 类加载机制分为五个部分：加载，连接（包括：验证，准备，解析），初始化，使用，卸载

## 1. 编译
即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件
类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程

## 2.加载过程
![[Pasted image 20230509154820.png]]

### 加载
**加载**是**类加载**过程中的一个阶段

将 class 文件字节码内容，生成类的元数据放入**方法区**中，里面放置了类的基本信息，包括类的版本、字段、方法、接口以及常量池表（Constant Pool Table）等**运行时数据结构**。**Java的对象（包括class对象）中保存着指向相应类的元数据的引用**。


这个阶段会还在**堆**中生成一个代表这个类的`java.lang.Class`对象，作为这个类在方法区的元数据的访问入口，也就是说**Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口**

这个过程需要[[[类加载器]]]参与

1. 通过一个类的全限定名获取类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

4. ZIP包读取，如jar包，war包
5. 从网络读取
6. 运行时生成，动态代理
7. 其他文件生成，如jsp文件生成对应的class类

### 验证
确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

### 准备
正式为**类变量**分配内存并设置类变量的初始值阶段，在方法区中分配这些变量所使用的内存空间
如
```java
public static int v = 123;
```
在准备阶段过后的初始值为 0，在初始化阶段才会赋值
但如果是**类常量**
```java
public static final int v = 123;
```
则在准备阶段就会赋值为123

### 解析
将符号引用替换为直接引用过程，这一步可以发生在运行时

### 符号引用
即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息

### 直接引用
可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量

由于在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，所以如果你在一个类中引用了另一个类，那么你完全无法知道他的内存地址，那怎么办，我们只能用他的类名作为符号引用，在类加载完后用这个符号引用去获取他的内存地址

比如说多态中的动态绑定，要到运行时再去替换符号引用，因为在类加载时还没有明确的类型

### 初始化

___
# 加载时期
类加载的时机
关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行 强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之 前开始）：

## new 和 访问静态成员、方法
1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有： ·使用new关键字实例化对象的时候。 ·读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候。 ·调用一个类型的静态方法的时候。

## 反射
2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。

## 子类加载会先加载父类及接口
3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

## main 函数的类
4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类。

5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。


