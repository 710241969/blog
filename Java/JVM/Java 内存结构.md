___
# Java 内存区域
![[Pasted image 20230519002340.png]]


根据《Java 虚拟机规范（Java SE 7 版）》的规定， Java 虚拟机所管理的内存将会包括以下几个运行时数据区域
![](../../img/20190313112941.png)
JAVA 虚拟机运行时数据区

## 程序计数器 Promgram Counter Register
程序计数器 (Promgram Counter Register) 是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空 (Undefined) 。
此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

关键字：
* **线程私有**
* **字节码行号**
* **没有规定 OutOfMemoryError**

## Java虚拟机栈 Java Virtual Machine Stacks
与程序计数器一样， Java 虚拟机栈 (Java Virtual Machine Stacks) 也是线程私有的，它的声明周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧 (Stack Frame ，方法运行时的基础数据结构) 用于存储
* **局部变量表**
* **操作数栈**
* **动态链接**
* **方法出口**
等信息。

**每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程**。

经常有人把 Java 内存区分为堆内存 (Heap) 和栈内存 (Stack) ，这种分法比较粗糙， Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。这里的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。

局部变量表存放了编译期可知的各种基本数据类型 (boolean 、 byte 、 char 、 short 、 int 、 float 、 long 、 double）、对象引用(reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和 returnAddress 类型（指向了一条字节码指令的地址）。

其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间 (Slot)，其余的数据类型只占用 1 个。**局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的**，在方法运行期间不会改变局部变量表的大小。

在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。
关键词：
* **线程私有**
* **栈帧**
* **局部变量表、操作数栈、动态链接、方法出口**
* **局部变量在编译期间完成空间分配**
* **StackOverflowError**
* **OutOfMemoryError**

### 本地方法栈 Native Method Stack
本地方法栈 (Native Method Stack) 与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用范式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如 Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。
关键词：
* **线程私有**
* **Native 本地方法**
* **StackOverflowError**
* **OutOfMemoryError**

### Java 堆 Java Heap
对于大多数应用来说， Java 堆 (Java Heap) 是 Java 虚拟机锁管理内存中最大的一块。 Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微秒的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。
Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆” (Garbage Collected Heap) 。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、 From Survivor 空间、 To Survivor 空间等。从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓存区 (Thread Local Allocation Buffer, TLAB) 不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。
根据 Java 虚拟机规范的规定， Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可能是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。

jdk1.8
现在主要有：
* 对象实例
类初始化生成的对象
基本数据类型的数组也是对象实例
* 字符串常量池
字符串常量池原本存放于方法区，jdk7开始放置于堆中。
字符串常量池存储的是string对象的直接引用，而不是直接存放的对象，是一张string table
* 静态变量
静态变量是有static修饰的变量，jdk7时从方法区迁移至堆中
* 线程分配缓冲区（Thread Local Allocation Buffer）
线程私有，但是不影响java堆的共性
增加线程分配缓冲区是为了提升对象分配时的效率
关键词：
* **所有线程共享**
* **对象实例**
* **垃圾收集**
* **空间不连续**
* **OutOfMemoryError**

## 方法区 Method Area
方法区 (Method Area) 与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap （非堆），目的应该是与 Java 堆区分开来。
对于习惯在 HotSpot 虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区成为“永久代” (Permanent Generation) ，本质上两者并不等价，仅仅是因为 HotSpot 虚拟机的设计团队选择把 GC 分代收集拓展至方法区，或者说使用永久代来实现方法区而已，这样 HotSpot 的垃圾收集器可以像管理 Java 堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他虚拟机（如 BEA JRockit 、 IBM J9 等）来说是不存在永久代的概念的。使用永久代来实现方法区现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有 -XX MaxPermSize 的上限， J9 和 JRockit 只要没有触碰到进程可用内存的上限，例如 32 位系统中的 4GB ，就不会出现为题），而且有极少数方法（例如 String.intern()）会因这个原因导致不同虚拟机有不同表现。因此对于 HotSpot 虚拟机，现在也有放弃永久代并逐步改为采用 Native Memory 来实现方法区的规划了，在目前已经发布的 JDK1.7 的 HotSpot 中，已经把原本放在永久代的字符串常量池移出。
Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收比较难以让人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。
根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。
关键词：
* **所有线程共享**
* **类信息、常量**
* **垃圾收集**
* **OutOfMemoryError**

方法区是所有线程共享的内存，在java8以前是放在JVM内存中的，由永久代实现，受JVM内存大小参数的限制，在java8中移除了永久代的内容，方法区由元空间(Meta Space)实现，

并直接放到了本地内存中，不受JVM参数的限制（当然，如果物理内存被占满了，方法区也会报OOM），并且将原来放在方法区的字符串常量池和静态变量都转移到了Java堆中

### 类元信息（Klass）
类元信息在类编译期间放入方法区，里面放置了类的基本信息，包括类的版本、字段、方法、接口以及常量池表（Constant Pool Table）
常量池表（Constant Pool Table）存储了类在编译期间生成的字面量、符号引用(什么是字面量？什么是符号引用？)，这些信息在类加载完后会被解析到运行时常量池中

### 运行时常量池（Runtime Constant Pool）
运行时常量池主要存放在类加载后被解析的字面量与符号引用，但不止这些
运行时常量池具备动态性，可以添加数据，比较多的使用就是String类的intern()方法

### 运行时常量池 Runtime Constant Pool
运行时常量池 (Runtime Constant Pool) 是方法区的一部分。 Class 文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池 (Constant Pool Table) ，用于存放编译期生成的各种**字面量**和**符号引用**，这部分内容将在类加载后进入方法区的运行时常量中存放。
Java 虚拟机对 Class 文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池， Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。
运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性， Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。
既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。
关键词：
* **方法区**
* **OutOfMemoryError**

### 直接内存 Direct Memory
直接内存 (Direct Memory) 并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现，所以我们放到这里一起讲解。
在 JDK1.4 中新加入了 NIO(New Input/Output) 类，引入了一种基于通道 (Channel) 与缓冲区 (Buffer)  的 I/O 方式，它可以使用 Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。
本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常忽略直接内存、使得各个内存区域综合大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。
关键词：
* **NIO**
* **OutOfMemoryError**

方法区 所有的线程共享 要加载的类信息（类名、方法信息、字段信息）、常量、静态变量、JIT

堆 所有的线程共享 存放对象的实例本身

栈 基础数据类型对象 自定义对象的的引用 每个线程独立私有

程序计数器 指向当前线程执行到的字节码文件的行数，线程独立私有 唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域

虚拟机栈（JVM栈） 单位：栈帧 局部变量表（编译时就确定了大小 slot变量槽（最大是一个int类型，可重用）） 操作数栈（线程正在执行的方法） 动态链接（多态） 出口（出栈 1.正常出栈 2.异常出栈） 每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程

本地方法栈 native 关键字 本地方法存储的地方，java最底层的一些方法、操作，由 c\c++ 编写，和系统硬件底层的交互。如 CAS 



___
# 常见问题总结

## 成员变量、局部变量、类变量分别存储在内存的什么地方？

### 类变量
类变量是用static修饰符修饰，定义在方法外的变量，随着java进程产生和销毁
在java8之前把静态变量存放于方法区，在java8时存放在堆中

### 成员变量
成员变量是定义在类中，但是没有static修饰符修饰的变量，随着类的实例产生和销毁，是类实例的一部分
由于是实例的一部分，在类初始化的时候，从运行时常量池取出直接引用或者值，与初始化的对象一起放入堆中

### 局部变量
局部变量是定义在类的方法中的变量
在所在方法被调用时放入虚拟机栈的栈帧中，方法执行结束后从虚拟机栈中弹出，所以存放在虚拟机栈中

## 由`final`修饰的常量存放在哪里？
**`final`关键字并不影响在内存中的位置**，取决于他是类变量、成员变量还是局部变量，参考[[#成员变量、局部变量、类变量分别存储在内存的什么地方？]]



Java中的Class也是一个类，所以Class对象也存放在堆当中，存放在方法区当中的是类的元数据，即类加载器从class文件中提取出来的类型信息、方法信息、字段信息等。

Java的对象（包括class对象）中保存着指向相应类的元数据的引用，元数据中又保存着指向class对象的引用
        
什么是字面量？什么是符号引用？
字面量

java代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示:

int a=1;//这个1便是字面量
String b="iloveu";//iloveu便是字面量
复制
符号引用

由于在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，所以如果你在一个类中引用了另一个类，那么你完全无法知道他的内存地址，那怎么办，我们只能用他的类名作为符号引用，在类加载完后用这个符号引用去获取他的内存地址。

例子：我在com.demo.Solution类中引用了com.test.Quest，那么我会把com.test.Quest作为符号引用存到类常量池，等类加载完后，拿着这个引用去方法区找这个类的内存地址。