___
# 概述
零拷贝一般指的是从磁盘读取文件发送到网络或者从网络接收数据写入到磁盘文件的过程中，减少数据的拷贝次数。

- **`零拷贝`** 是 **`直接内存`** 的 **特征**，**`直接内存`** 是 **`零拷贝`** 的 **实现原理**
- **`零拷贝`** 并 **不是** 代表 **不进行拷贝**，而是 少了 **用户空间** 和 **内核空间** 之间的拷贝，但是 数据从 **`直接内存`** 与 **`磁盘/网卡`** 的 拷贝确是 少不了的
- **零拷贝并不是指的数据一次拷贝都没有发生，而是指减少CPU进行数据拷贝的次数。**
___
# 直接内存（Direct Memory）
并 **不是** **虚拟机运行时数据区** 的一部分，也**不是** **Java虚拟机规范中定义的内存区域**，  
某些情况下这部分内存也会被频繁地使用，而且也可能导致OutOfMemoryError异常出现。  
Java里用 **DirectByteBuffer** 可以分配一块 **直接内存(堆外内存)**，**元空间** 对应的内存也叫作 **直接内存**，它们对应的都是 **机器的物理内存**

如下图：  
![直接内存](https://img-blog.csdnimg.cn/20210501181922976.png)  
我们可以看到：
**`直接内存`**，只是在 **虚拟机内存** 中，创建了一个**指针引用**  
而 指针所指的 **实例数据存储** 却在 虚拟机内存之外 的 **本机物理内存**上

### 优点：
- **不占用堆内存空间，减少了发生GC的可能**
-  java虚拟机实现上，**本地IO** 会直接操作 **直接内存**（**直接内存=>系统调用=>硬盘/网卡**），  
- 而 **非直接内存** 则需要 **二次拷贝**（**堆内存=>直接内存=>系统调用=>硬盘/网卡**）

### 缺点：
-   **初始分配** 较 **慢**
-   **没有** JVM直接 **帮助管理内存**，容易发生 **OOM**。  
为了避免一直没有FULL GC，最终导致直接内存把物理内存耗完。  
我们可以指定直接内存的最大值，通过 **-XX：MaxDirectMemorySize** 来指定，  
当达到阈值的时候，调用system.gc来进行一次FULL GC，间接把那些没有被使用的直接内存回收掉。

___
# DMA
直接内存访问（_DMA_，Direct Memory Access）


___
# MMAP
memory map，也就是内存映射

**MappedByteBuffer 便是 Java 中的 mmap 操作类。**


**MappedByteBuffer减少了从内核缓冲区到用户缓冲区的数据拷贝，可以直接将内核缓冲区的数据拷贝到网络缓冲区。**

___
# sendfile
linux在2.1版本中引入了sendfile函数，可以实现将数据从一个文件描述符传输到另外一个文件描述符：

1.  发起sendfile系统调用，进入到内核空间；
2.  DMA从磁盘读取文件到内核缓冲区（DMA复制）；
3.  将内核缓冲区数据拷贝到socket缓冲区（CPU复制）；
4.  将socket缓冲区数据拷贝到网卡（DMA复制），之后切换回用户空间；  
    ![](https://img2022.cnblogs.com/blog/2612945/202210/2612945-20221005212958809-2019248521.png)

**sendfile减少了一次数据从内核缓冲区拷贝到用户缓冲区的过程，可以直接将内核缓冲区的数据拷贝到socket缓冲区。**

___
# JAVA 实现
Java+NIO实现零拷贝
在java中可以使用：
1. MappedByteBuffer 和 fileChannel.map() 等函数来实现零拷贝，MMAP
2. fileChannel.transferTo()，sendfile

其中：
mmap适合小数据量的传输, RocketMQ使用的就是mmap。
sendFile 适合大数据量的传输，Kafka使用的就是sendFile。





