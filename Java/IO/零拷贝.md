___
# 概述
零拷贝一般指的是从磁盘读取文件发送到网络或者从网络接收数据写入到磁盘文件的过程中，减少数据的拷贝次数。

- **`零拷贝`** 是 **`直接内存`** 的 **特征**，**`直接内存`** 是 **`零拷贝`** 的 **实现原理**
- **`零拷贝`** 并 **不是** 代表 **不进行拷贝**，而是 少了 **用户空间** 和 **内核空间** 之间的拷贝，但是数据从 **`直接内存`** 与 **`磁盘/网卡`** 的拷贝确是少不了的。 **用户空间** 和 **内核空间** 之间的拷贝由 CPU 完成。
- **零拷贝并不是指的数据一次拷贝都没有发生，而是指减少CPU进行数据拷贝的次数。**

## 零拷贝给我们带来的好处
- 减少甚至完全避免不必要的 CPU 拷贝，从而让 CPU 解脱出来去执行其他的任务；
- 减少内存带宽的占用；
- 通常零拷贝技术还能够减少用户空间和操作系统内核空间之间的上下文切换。

## 操作系统中谁负责IO拷贝？
DMA 负责内核间的 IO 传输，CPU 负责内核和应用间的 IO 传输。

两种拷贝类型：

（1）CPU COPY
通过计算机的组成原理我们知道, 内存的读写操作是需要 CPU 的协调数据总线,地址总线和控制总线来完成的因此在"拷贝"发生的时候,往往需要 CPU 暂停现有的处理逻辑,来协助内存的读写，这种我们称为 CPU COPY。CPU COPY 不但占用了 CPU 资源,还占用了总线的带宽。

（2）DMA COPY
DMA(DIRECT MEMORY ACCESS) 是现代计算机的重要功能，它有一个重要特点：当需要与外设进行数据交换时, CPU 只需要初始化这个动作便可以继续执行其他指令,剩下的数据传输的动作完全由DMA来完成可以看到 DMA COPY 是可以避免大量的 CPU 中断的。

## **存在多次拷贝的原因**

操作系统为了保护系统不被应用程序有意或无意地破坏，为操作系统设置了用户态和内核态两种状态，用户态想要获取系统资源(例如访问硬盘)，必须通过系统调用进入到内核态, 由内核态获取到系统资源，再切换回用户态返回应用程序。

出于 "readahead cache" 和异步写入等等性能优化的需要, 操作系统在内核态中也增加了一个"内核缓冲区"(kernel buffer)。读取数据时并不是直接把数据读取到应用程序的 buffer， 而先读取到 kernel buffer， 再由 kernel buffer 复制到应用程序的 buffer。因此,数据在被应用程序使用之前，可能需要被多次拷贝。

一次 read-send 涉及到了四次拷贝:

1.  硬盘拷贝到内核缓冲区(DMA COPY)；
2.  内核缓冲区拷贝到应用程序缓冲区(CPU COPY)；
3.  应用程序缓冲区拷贝到socket缓冲区(CPU COPY)；
4.  socket buf拷贝到网卡的buf(DMA COPY)。

其中涉及到2次 CPU 中断, 还有4次的上下文切换。很明显,第2次和第3次的的 copy 只是把数据复制到 app buffer 又原封不动的复制回来, 为此带来了两次的 CPU COPY 和两次上下文切换, 是完全没有必要的。

Linux 的零拷贝技术就是为了优化掉这两次**不必要的拷贝**

___

# Linux 做法

## sendfile
linux在2.1版本中引入了sendfile函数，可以实现将数据从一个文件描述符传输到另外一个文件描述符：

1.  发起sendfile系统调用，进入到内核空间；
2.  DMA从磁盘读取文件到内核缓冲区（DMA复制）；
3.  将内核缓冲区数据拷贝到socket缓冲区（CPU复制）；
4.  将socket缓冲区数据拷贝到网卡（DMA复制），之后切换回用户空间；  
    ![](https://img2022.cnblogs.com/blog/2612945/202210/2612945-20221005212958809-2019248521.png)

**sendfile减少了一次数据从内核缓冲区拷贝到用户缓冲区的过程，可以直接将内核缓冲区的数据拷贝到socket缓冲区。**

# 支持 scatter-gather 特性的 sendFile 的 IO
Linux在内核2.4以后的版本中, Linux 内核对 socket 缓冲区描述符做了优化。通过这次优化, sendFile 系统调用可以在只复制 kernel buffer 的少量元信息的基础上, 把数据直接从 kernel buffer 复制到网卡的 buffer 中去，从而避免了从"内核缓冲区"拷贝到"socket缓冲区"的这一次拷贝。

这个优化后的 sendFile, 我们称之为支持 scatter-gather 特性的 sendFile。

最后数据拷贝变成只有两次 DMA COPY:

硬盘拷贝到内核缓冲区(DMA COPY)；
内核缓冲区拷贝到网卡的 buf(DMA COPY)。

___

# DMA
直接内存访问（_DMA_，Direct Memory Access）
DMA方式由硬件实现

___
# JAVA 实现
Java+NIO实现零拷贝
在java中可以使用：
1. MappedByteBuffer 和 fileChannel.map() 等函数来实现零拷贝，MMAP
2. fileChannel.transferTo()，sendfile

其中：
mmap适合小数据量的传输, RocketMQ使用的就是mmap。
sendFile 适合大数据量的传输，Kafka使用的就是sendFile。

## MMAP
memory map，也就是内存映射

**MappedByteBuffer 便是 Java 中的 mmap 操作类。**

**MappedByteBuffer减少了从内核缓冲区到用户缓冲区的数据拷贝，可以直接将内核缓冲区的数据拷贝到网络缓冲区。**

## 直接内存（Direct Memory）
并 **不是** **虚拟机运行时数据区** 的一部分，也**不是** **Java虚拟机规范中定义的内存区域**，  
某些情况下这部分内存也会被频繁地使用，而且也可能导致OutOfMemoryError异常出现。  
Java里用 **DirectByteBuffer** 可以分配一块 **直接内存(堆外内存)**，**元空间** 对应的内存也叫作 **直接内存**，它们对应的都是 **机器的物理内存**

如下图：  
![直接内存](https://img-blog.csdnimg.cn/20210501181922976.png)  
我们可以看到：
**`直接内存`**，只是在 **虚拟机内存** 中，创建了一个**指针引用**  
而 指针所指的 **实例数据存储** 却在 虚拟机内存之外 的 **本机物理内存**上

### 优点：
- **不占用堆内存空间，减少了发生GC的可能**
-  java虚拟机实现上，**本地IO** 会直接操作 **直接内存**（**直接内存=>系统调用=>硬盘/网卡**），  
- 而 **非直接内存** 则需要 **二次拷贝**（**堆内存=>直接内存=>系统调用=>硬盘/网卡**）

### 缺点：
-   **初始分配** 较 **慢**
-   **没有** JVM直接 **帮助管理内存**，容易发生 **OOM**。  
为了避免一直没有FULL GC，最终导致直接内存把物理内存耗完。  
我们可以指定直接内存的最大值，通过 **-XX：MaxDirectMemorySize** 来指定，  
当达到阈值的时候，调用system.gc来进行一次FULL GC，间接把那些没有被使用的直接内存回收掉。



