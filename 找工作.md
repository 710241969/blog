我叫张三，今年 25 岁，18 年从交大大学毕业，计算机系，目前有 3 年 Java 开发经验（这个是 jd 上
的要求），有 Oracle,MySQL 的开发经验，有 xx 等技术经验（这些经验也是 jd 上的要求）

在项目里，我用过用索引和执行计划等进行数据库调优经验，有 JVM 方面排查 OOM 的经验，大数据
方面，用过 Spark 等框架，分布式组件方面，用过 Redis 和 Dubbo 等，有在 linux 上看日志然后排
查线上问题的经验


在最近的项目里，我用到了 Spring Boot 框架，具体用到了 JPA 组件，数据库用 Oracle，最近的项目
是 xx 系统，用到了敏捷开发模式，在这个项目里，我除了做 coding 外，还做过单元测试，讨论需求
和详细设计等工作，并且最近的项目进度比较紧，我自己感觉还能主动加班，一起和同事们保质保量
地完成项目。

我最近是在 xx 公司（以此突出商业项目）里做了 xx 项目，这个项目的客户方是 xx，已经上线（但如
果是 web 项目面试官大概率会去核对）。这个项目用到了敏捷开发模式（提一下别展开，算抛出个提
问点）， 这个项目组人员是 xx 人，做了 n 个月，我在里面做了 xx 和 xx 模块。

在这个项目里，我们用到了 maven，用 git 来管理代码，用 jira 来管理任务和 bug，用 jenkins 工具
来发布。我还用过 junit 编写过单元测试，我们还用 sonar 来统计代码的测试覆盖度，我们项目经理要
求，只有当“行覆盖率高于 80%”，代码才能提交

我在使用 junit 时，不会敷衍地编写案例，而会根据真实的业务数据来编写案例，并且我还会着重考虑
各种边界情况（这些哪怕初级开发也有本事做到），而且在编写代码时，我会非常注意编码规范，比
23
如定义变量时会让人一看就理解 ，在关键代码地方多写注释，在 if 等条件里不会写太复杂，一个方法
不会写太长，或者你可以再说些其它好的编码规范。而且，一旦遇到我的 bug，我会第一时间跟进，
并会和相关对应的人一起解决掉。

# 工作介绍
我最近是在深圳虾皮信息有限公司，在商户管理及交易支付团队，做的是东南亚的是 TOB 业务
整个团队共 190 人。用 jira 来管理任务和 bug ，用 jenkins + K8S 工具
来做发布和持续交付。
团队包括整个公司都是 Golang 技术栈，用 GRPC 框架微服务框架，数据库用的 MySQL

# 项目内容
ArPay counter业务(简称APC)是一个虚拟/电子物品电商平台，向用户售卖电话卡、游戏点卡等虚拟物品，同时提供代缴水电费等服务。APC本身扮演了中间商的角色，卖给用户的电话卡是上游供货商最终提供的

交易支付就是负责其中的，用户下单、支付、资金流转、通知发货，这个流程的业务，包括一些 admin 后台管理操作。
整个架构是：支付模块——钱包模块

一开始交易支付和商品发货管理等一些下游服务是耦合的，一开始支付成功，会调用下游发货接口，但是后面有别的服务要接入，希望能得到我们支付成功的消息，如果每个下游都用接口方式去通知，维护起来就很麻烦，所以接入了 kafka ，解耦上下游服务

钱包模块尽量职责单一，没有引入别的中间件。所以 kafka 消息这一步是在支付模块产生的，而且是异步操作。

延迟队列保证支付钱包连个个模块的最终一致性，同时确保支付成功消息的成功推送。延迟队列是单独自研的一个服务，队列基于 Redis Zset 来实现的，队列任务通过 RPC 调用目标服务的接口触发。在交易模块调用支付模块的建单过程，就往延迟队列插入单号。只有推 kafka 支付成功消息完成才会从队列删除。

延迟队列服务维护了一个 topic 表记录不同的任务，由开发维护，里面有 tpoic（redis 队列 key），目标服务名和方法，任务的处理时间间隔和次数，任务状态。

因为支付服务和钱包服务职责不一样，而且钱包模块很复杂，比较独立，所以两个服务的库是不一样的，这里就会出现数据状态不一致的问题。接口都设计成 TCC 规则。通过延迟队列保证最终一致性。

只要钱包动账成功的，都会走 commit 让整个交易终态走向成功；只要钱包还没完成动账的，都会走 cancel 流程，让整个交易终态走向失败。

一开始没有延迟队列补偿服务，每天由于网络问题、代码 BUG 问题导致的问题单不在少数，需要人工解决处理，也会受到 local 的投诉。通过这一系列完善，整个交易支付服务基础设施基本完备，得到良好运行。

后面就是分库分表的事情了。

# 分库分表


# 灰度发布


# 发现并解决了项目中使用的 http 库的一个问题
问题表现：线上大流量并发，上游服务请求下游服务，后续的请求全部出现超时
解决：本地通过开发环境复现，通过 wireshark 抓包，发现超时的请求其实 HTTP 连接过程中 TCP 连接其实很快的，但是还是在 5s 后直接发起关闭，推理是我们系统服务自己的问题。查看服务器 tcp 连接发现有大量正在关闭的连接，都是刚刚请求的连接，数量接近 6w
这个时候就知道大概是什么问题了
查看项目代码，发起 http 请求的地方，使用了一个 http 库，使用了他对象定义的成员变量来设置请求超时时间 5s，通过翻阅源码，发现这样会导致每个请求都建立一个连接，而不是使用连接池，所以在大流量的情况下出现了大量的连接超时
这时候通过用原生 http 库构建了一个超时时间 5s 的 HTTP client 传入这个库，就能使用到默认的连接池，发现连接数没有上来，请求也没有再超时 


gomock gomonkey
在我的推广和带领下，
地图附近商户搜索功能
通过监听 mysql binlog 实时同步商户信息到 ES


