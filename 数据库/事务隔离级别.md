
# 事务隔离问题
事务隔离级别，是为了解决所存在的不同问题，下面我们先来看看常见的几个问题
## 脏读
指读到了其他事务回滚的数据。
1. 当事务 A 更新数据，未提交
2. 事务 B 读到了事务 A 未提交的数据
3. 事务 A 进行事务回滚操作

此时，事务 B 刚刚读到的数据就是脏读

## 不可重复读
指在一个事务内，对同一行数据的读取得到的结果值不一样
1. 事务 A 读取数据
2. 事务 B 修改数据并提交
3. 事务 A 再次查询读取数据

此时，事务 A 读到最新提交的数据，和第一次读取的已经不一致了，就是不可重复读

## 幻读
类似不可重复读，但是幻读不是指同一行数据的不可重复读
幻读是指在一个事务内，同样的查询，返回了不同数量的结果，比如范围查询
1. 事务 A 进行条件查询，有一条记录
2. 事务 B 插入一条数据并提交，插入的数据符合事务 A 的查询条件
3. 事务 A 再次进行查询

此时，事务 A 发现比第一次查询多了记录（如果事务 B 是删除操作并提交，那么就是少了记录），这种因为数据结果集的数量变化导致的操作结果和预期不一致，就称为幻读

> Mysql 的可重复读隔离级别解决了上面的幻读问题，但是仍然有其他情况的幻读问题出现
> 参考[[#可重复读]]

---
# 事务隔离级别
## 读未提交 READ-UNCOMMITTED
最弱的事务隔离级别，等于是完全不隔离，操作相同数据的事务之间会互相影响
带来的问题有[[#脏读]]、[[#不可重复读]]、[[#幻读]]

## 读提交 READ-COMMITTED
操作相同数据的事务之间，未提交的数据不会相互影响，但是提交了的数据会被访问得到
解决了[[#脏读]]问题，但是仍然存在[[#不可重复读]]、[[#幻读]]问题

## 可重复读 SERIALIZABLE
事务之间得到了较好的隔离，同一事务相同记录数据的多次读取结果都是一致的
解决了[[#脏读]]、[[#不可重复读]]问题，但是仍然存在[[#幻读]]问题
可重复读是`Mysql`默认使用的隔离级别，通过[[MVCC]]解决了大部分情况下的幻读问题，但是仍然有一些幻读的情况出现，下面举个例子
1. 事务 A 条件查询 id=50 的数据，数据不存在
2. 事务 B 插入 id=50 的记录并提交
3. 事务 A 再次查询 id=50 的数据，数据还是不存在
4. 事务 A 对 id=50 的记录进行更新，显示更新成功
5. 事务 A 再次查询 id=50 的数据，数据出现了
再举个例子
1. 事务 A 条件查询 id=55 的数据不存在（当前读），查询 id>50 的数据（当前读），有4条数据
2. 事务 B 插入 id=55 的记录并提交
3. 事务 A 条件查询 id=55 的数据不存在（当前读），查询 id>50 的数据（当前读），有4条数据
4. 事务 A 条件查询 id=55 的数据不存在（当前读）；查询 id>50 的数据（当前读），有4条数据；查询 id>50 for update 的数据（快照读），出现了5条数据，id=55 的数据也出现了
这时两个例子都出现了幻读问题，因此`Mysql`也只是解决了大部分的幻读问题

## 串行化 SERIALIZABLE
最强的隔离级别，完全实现了事务隔离。所有事务串行执行，排队依次执行，避免了一切事务隔离问题问题，但是效率低

