MVCC，Multiversion Concurrency Control
多版本并发控制

___
# MySQL 隐藏字段
## DB_ROW_ID
6字节的DB_ROW_ID字段，包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。

**如果表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 聚簇索引会使用 DB_ROW_ID 的值来作为主键**; 

如果表中有主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID。

## DB_TRX_ID
6字节DB_TRX_ID字段，表示最后更新的事务id(update,delete,insert)。此外，删除在内部被视为更新，其中行中的特殊位被设置为将其标记为已软删除。

## DB_ROLL_PTR
7字节回滚指针，指向前一个版本的undolog记录，组成undo链表。如果更新了行，则撤消日志记录包含在更新行之前重建行内容所需的信息。

# 实现原理
MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。
基本特征
每行数据都存在一个版本，每次数据更新时都更新该版本。
修改时Copy出当前版本随意修改，各个事务之间无干扰。
保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）
InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现的。
在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。
每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。
插入数据（insert）:
记录的版本号即当前事务的版本号
更新操作：
采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式
删除操作：
就把事务版本号作为删除版本号
查询操作：
在查询时要符合以下两个条件的记录才能被事务查询出来：
1) 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)
2) 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert

MVCC只在READ COMMITED 和 REPEATABLE READ 两个隔离级别下工作。READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE 则会对所有读取的行都加锁

# 实现
这里都只讨论常用的可重复读隔离级别
MVCC的主要是通过 read view 和 undo log 来实现的
## read view 视图
实际上就是在查询时，InnoDB会生成一个read view。
事务执行时，数据库会创建一个视图，读未提交直接返回最新值，没有视图概念；串行是直接加锁避免并发访问；读已提交是在每个SQL语句开始执行时创建的视图。可重复读的视图是在事务启动的时候创建的，整个事务都会使用这个视图。

不同时刻启动的事务会有不同的视图，看到的值也就不一样，同一条行记录在数据库中可以存在多个版本，这就是多版本并发控制（MVCC）。

每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

### 数据结构
在实现上， **InnoDB 为每个事务构造了一个数组**，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。

**这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）**。

### 原理
数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的

这个视图数组把所有的 row trx_id 分成了几种不同的情况。
![[Pasted image 20230518152038.png]]
当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能:
1、如果 row trx_id 落在绿色部分，表示被访问的版本是已提交的事务或者就是当前事务自己生成的，这个数据是可见的；

2、如果 row trx_id 落在红色部分，表示被访问的版本还未开启，数据不可见；

3、如果 row trx_id 落在黄色部分，包括两种情况：
若 row trx_id 在 m_ids 集合中，表示被访问的版本尚未提交，数据不可见；
若 row trx_id 不在 m_ids 集合中，表示被访问的版本已经已经提交了，数据可见。

InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。

（1）trx_id：每次一个事务想要对主键索引进行更新、删除和新增时，都会把当前事务的事务id赋值给trx_id字段。注意事务id严格递增，且查询操作不会分配事务id，即trx_id = 0;

（2）DB_ROLL_PTR: 每次一个事务对主键索引进行更新时，都会把旧的版本写入到undo日志中， DB_ROLL_PTR 相当于一个指针指向上一个版本数据在 undo log 里的位置指针，通过它可以找到这条记录修改前的信息

MVCC其实就是靠「比对版本」来实现读写不阻塞，而版本的数据存在于undo log中

# 快照读
快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。
简单的select操作，属于快照读，不加锁。select * from table where ?;
对于可重复读，快照是在事务启动时创建的。
对于读提交，快照是每条语句执行的时候创建的。
快照就是这个事务 ID 的数组

# 当前读
当前读，读取的是记录的最新版本，并且当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。
当前读：读取的是最新版本，并且对读取的记录加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。
lock in share mode
for update
insert
update
delete

当前读的实现方式
当前读使用next-key锁(行记录锁+Gap间隙锁)实现


