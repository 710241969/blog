___
# 概述
**MySQL锁是加在索引记录上面的**

普通 SELECT 操作不加锁

# 记录锁（Record Locks）
又叫行锁
是独占锁

# 间隙锁（Gap Locks）
锁的就是两个值之间的空隙，用来防止 INSERT 操作的
间隙锁之间不存在冲突关系，只和写操作产生冲突

# 临键锁（Next-Key Locks）
间隙锁和行锁合称 next-key lock
是前开后闭区间

# 锁退化
原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
原则 2：查找过程中访问到的对象才会加锁。
优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

# 加锁方式
SELECT FOR UPDATE
INSERT
UPDATE
DELETE

# 加锁的具体分析
一条语句加什么锁，主要由几个方面决定
1. 表中存在的数据
2. 语句使用到的索引，不同的索引，加的锁类型、范围不一样。而且锁是加在索引上的，而不是所谓的“行”
3. 语句执行过程

## 常见问题
1. WHERE 条件中的列，不存在索引，会锁表
2. WHERE 条件中的列，存在索引，但是查询的数据不存在，会产生当前索引上大范围间隙锁
3. WHERE 条件中的列，存在普通索引，查询的数据存在，会产生普通索引查询范围内的间隙锁+命中记录的主键索引上的行锁
4. WHERE 条件中的列，存在唯一索引，查询的数据存在，会产生唯一索引命中记录的行锁+命中记录的主键索引上的行锁
4. WHERE 条件中的列，存在主键索引，查询的数据存在，会产生命中记录的主键索引上的行锁

## 间隙锁的自动膨胀
表中三条数据，id 1，5，10
事务 A 锁住 (5,10)，不提交
事务 B 删除 5 ，提交，成功
事务 C 插入 2，失败，因为 A 的锁在 B 事务提交删除后，扩大到 (1,10) 了

# 查看当前的锁
```
select * from performance_schema.data_locks;
```

