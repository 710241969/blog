___
# 数据结构
B+树也是一个平衡二叉树，非叶子节点有 key，叶子节点有 key 和数据
和B树的区别是，B+树数据存储在叶子节点，通过双向链表连接，从左到右有序递增

## 为什么快？为什么用 B+ 树
主要是为了减少 IO 操作
同时将随机 IO 变成顺序 IO（存疑？）

1. B+树矮，3层的 B+ 树只需要 3 次 IO 操作。我们到系统中获取数据最少需要两个步骤，先从磁盘中读出在放到内存中，每次读出的数据为一个磁
盘块(单位)，这种操作称为一次IO。
2. 从磁盘读出的数据加载在内存中，数据比较在内存中完成。通过二分查找，提高查找效率。
3. 操作系是按数据页大小来访问硬盘的，每次 IO 只读取一个数据页大小的数据。innodb存储最小单位是页，一页数据16kb，每次都能读取到多行相邻数据。如果读到的数据都在查询范围内，就直接减少了后续的查询。
4. 非叶子节点不存数据，只存 key ，那么 16k 的大小能放更多数据
5. 叶子节点通过双向链表连接，有序，适合范围查询


## 为什么不用二叉树？为什么不用红黑树？
数据量大的情况下，二叉树层级很深，效率很低，增加硬盘的 I/O 次数

## 为什么不用 hash 表
因为要范围查询


___
# 主键索引和聚集索引
聚集索引确定表中数据的物理顺序，聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。可以说聚集索引就是表数据自身的顺序。

主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。

Innodb 通过主键聚集数据
如果没有定义主键，innodb会选择非空的唯一索引代替。
如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引

## 自增主键好处
B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。如果插入的值比最大值id大，则只需要最后记录后面插入一个新记录。如果新插入的ID值在原先的有序中间，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。如果所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。
除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

___
# 非主键索引
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，**非主键索引也被称为二级索引**（secondary index）。

___
# 主键索引和唯一索引的区别
* 一个表的主键只能有一个，而唯一索引可以建多个。
* 主键不可为 null ，唯一索引列的值可以为 null 。
* 主键索引的叶子节点是数据，唯一索引的叶子节点内容是主键的值。

___
# 聚集索引和非聚集索引的区别
* 一个表的聚集索引只能有一个，而非聚集索引索引可以建多个。
* 聚集索引不可为 null ，非聚集索引值可以为 null 。
* 聚集索引的叶子节点是数据，非聚集索引的叶子节点内容是主键的值。

___
# 索引失效
- like 以%开头索引无效，当 like 以&结尾，索引有效。
- or 语句前后没有同事使用索引，**当且仅当 or 语句查询条件的前后列均为索引时**，索引生效。
- 组合索引，使用的不是第一列索引时候，索引失效，即最左匹配规则。
- 数据类型出现**隐式转换**，如 varchar 不加单引号的时候可能会自动转换为 int 类型，这个
时候索引失效。
- **在索引列上使用 IS NULL 或者 IS NOT NULL 时候，索引失效，因为索引是不索引空值
得**
- 在索引字段上使用，NOT、 <>、！= 、时候是不会使用索引的，对于这样的处理只会进
行全表扫描。
- 对索引字段进行**计算操作**，函数操作时不会使用索引，如 `WHERE id+1=5`
- 当全表扫描速度比索引速度快的时候不会使用索引。

___
# `Select count(*)` 的优化
InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 `count(*)` 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，**MySQL 优化器会找到最小的那棵树来遍历**。在保证逻辑正确的前提下，**尽量减少扫描的数据量，是数据库系统设计的通用法则之一**。

如果你用过 show table status 命令的话，就会发现这个命令的输出结果里面也有一个 TABLE_ROWS 用于显示这个表当前有多少行，这个命令执行挺快的，那这个 TABLE_ROWS 能代替 count(*) 吗？

索引统计的值是通过采样来估算的。实际上，TABLE_ROWS 就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到 40% 到 50%。所以，show table status 命令显示的行数也不能直接使用。

count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。所以，`count(*)`、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。

## 对于 count(主键 id) 来说
InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。

## 对于 count(1) 来说
InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。

## 对于 count(字段) 来说
1. 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
2. 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。
也就是一条原则，server 层要什么字段，InnoDB 就返回什么字段。

## `count(*)`是例外
`count(*)`并不会把全部字段取出来，而是专门做了优化，不取值。`count(*)` 肯定不是 null，按行累加。

所以结论是：按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(*)，所以我建议你，尽量使用 count(*)。

___
# 
