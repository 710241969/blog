___
双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843KaMMu2mHfFLZNgiaREDZ5JicRYrlaiciayQjh9HDsacxIbMT0emGUpAX5w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1 "客户端主动关闭连接 —— TCP 四次挥手")

客户端主动关闭连接 —— TCP 四次挥手

-   客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。

-   服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。

-   客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。

-   等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。

-   客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态

-   服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。

-   客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。


你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。
这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**

___
# 为什么要四次
再来回顾下四次挥手双方发 FIN 包的过程，就能理解为什么需要四次了。

-   关闭连接时，主动方向被动方发送 FIN 时，仅仅表示主动方不再发送数据了但是还能接收数据。
-   被动方收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而被动方可能还有数据需要处理和发送，等被动方不再发送数据时，才发送 FIN 报文给主动方来表示同意现在关闭连接。

从上面过程可知，被动方通常需要等待完成数据的发送和处理，所以被动方的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。

___
# 为什么要等待 2MSL(Maximum Segment Lifetime)
问题一：防止旧连接的数据包
假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后，这时有相同端口的 TCP 连接被复用后，连接重新建立，上个连接被延迟的数据包抵达了主动方，那么主动方是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题
经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。

问题二：**保证连接正确关闭，或者说帮助对方关闭**
- 如过主动方四次挥手的最后一个 ACK 报文如果在网络中被丢失了，此时如果主动方 TIME-WAIT 过短或没有，则就直接进入了 CLOSE 状态了，那么被动方则会一直处在 LAST-ACK 状态。
- 此时如果被动方重发 FIN，能得到 RST 回应，没有问题。但是如果，此时短时间内当主动方又发起建立连接的 SYN 请求报文后，被动方会发送 RST 报文给主动方，连接建立的过程就会被终止。
- 
由于每次收到 FIN 报文会重置 TIME_WAIT 时间，2MSL 可以保证如果自己最后发出的 ACK 对方未收到，还能收到对方重发的 FIN 报文。

我们设想有一个处于拆链过程中的TCP连接，这个连接的两端分别是A和B，其中A是主动关闭连接的一端，因为刚刚向对端发送了针对对端发送过来的FIN报文的ACK，此时正处于TIME_WAIT状态；而B是被动关闭的一端，此时正处于LAST_ACK状态，在收到最后一个ACK之前它会一直重传FIN报文直至超时。随着时间的流逝，A发送给B的ACK报文将会有两种结局：

ACK报文在网络中丢失；如前所述，这种情况我们不需要考虑，因为除非多次重传失败，否则AB两端的状态不会发生变化直至某一个ACK不再丢失。

ACK报文被B接收到。我们假设A发送了ACK报文后过了一段时间t之后B才收到该ACK，则有 0 < t <= MSL。因为A并不知道它发送出去的ACK要多久对方才能收到，所以A至少要维持MSL时长的TIME_WAIT状态才能保证它的ACK从网络中消失。同时处于LAST_ACK状态的B因为收到了ACK，所以它直接就进入了CLOSED状态，而不会向网络发送任何报文。所以晃眼一看，A只需要等待1个MSL就够了，但仔细想一下其实1个MSL是不行的，因为在B收到ACK前的一刹那，B可能因为没收到ACK而重传了一个FIN报文，这个FIN报文要从网络中消失最多还需要一个MSL时长，所以A还需要多等一个MSL。

综上所述，TIME_WAIT至少需要持续2MSL时长，这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失。另外，虽然说维持TIME_WAIT状态一段时间有2个目的，但这段时间具体应该多长主要是为了达成上述第二个目的而设计的。

___
# 服务器在对外服务时，是「客户端」发起的断开连接？还是「服务器」发起的断开连接？

正常情况下，都是「客户端」发起的断开连接
「服务器」一般设置为「不主动关闭连接」，服务器通常执行「被动关闭」
但 HTTP 请求中，http 头部 connection 参数，可能设置为 close，则，服务端处理完请求会主动关闭 TCP 连接
关于 HTTP 请求中，设置的主动关闭 TCP 连接的机制：TIME_WAIT的是主动断开方才会出现的，所以主动断开方是服务端？

1.答案是是的。在HTTP1.1协议中，有个 Connection 头，Connection有两个值，close和keep-alive，这个头就相当于客户端告诉服务端，服务端你执行完成请求之后，是关闭连接还是保持连接，保持连接就意味着在保持连接期间，只能由客户端主动断开连接。还有一个keep-alive的头，设置的值就代表了服务端保持连接保持多久。

2.HTTP默认的Connection值为close，那么就意味着关闭请求的一方几乎都会是由服务端这边发起的。那么这个服务端产生TIME_WAIT过多的情况就很正常了。

3.虽然HTTP默认Connection值为close，但是，现在的浏览器发送请求的时候一般都会设置Connection为keep-alive了。所以，也有人说，现在没有必要通过调整参数来使TIME_WAIT降低了

# timewait 过多
如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。

过多的 TIME-WAIT 状态主要的危害有两种：
-   第一是内存资源占用；
-   第二是对端口资源的占用，一个 TCP 连接至少消耗连接发起方的一个本地端口；

**如果服务端 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。**

## 解决方法
**快速回收连接**
net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。

**复用处于 TIME_WAIT 的 socket 为新的连接所用**
net.ipv4.tcp_tw_reuse = 1表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即
```
net.ipv4.tcp_timestamps=1（默认即为 1）
```
温馨提醒：net.ipv4.tcp_tw_reuse要慎用，因为使用了它就必然要打开时间戳的支持 net.ipv4.tcp_timestamps，当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉。

net.ipv4.tcp_fin_timeout修改系統默认的TIMEOUT时间

